import Manager from "../managers/Manager";
import gameConfig from "../system/gameConfig";
import SocketManager from "./SocketManager";
import { GameInit, GameLoaded } from "../../../common/MessageTypes";

import CST from "../CST";
import BuildingsMessenger from "./BuildingsMessenger";
import { IsoScene } from "../IsoPlugin/IsoPlugin";

export default class GameManager extends Manager {
  private gameInstance: Phaser.Game;
  private socketManager: SocketManager;

  // The messengers used to send events to the server
  public messengers: {
    buildings?: BuildingsMessenger;
  } = {};

  // The seed generated by the server for this game to use
  public seed: string;

  private constructor() {
    super();

    // Init the socket manager
    this.socketManager = SocketManager.getInstance();

    this.messengers.buildings = new BuildingsMessenger(this.socketManager);

    // When connected to the server, start listening for the game init event
    this.socketManager.events.once(CST.IO.EVENTS.CONNECT, () => {
      this.listenForInitEvent();
    });
  }

  // Listen for the init event and expect the initial game config
  // This event will fire MULTIPLE times if connection is lost and another socket is allocated server-side
  private listenForInitEvent() {
    this.socketManager.on(GameInit.EVENT, (initConfig: GameInit.Config) => {
      // If for some reason, this event fires multiple times
      // and the game is already running, just ignore it
      if (this.gameInstance) {
        // But fire the load event because the game is already loaded
        this.socketManager.emit(GameLoaded.EVENT);

        return;
      }

      ({ seed: this.seed } = initConfig);

      this.messengers.buildings.initialBuildings = initConfig.buildings;
      this.gameInstance = new Phaser.Game(gameConfig);

      this.waitForGameLoad();
    });
  }

  // Wait for Game Load to send the gameloaded event to the server
  private waitForGameLoad(): Promise<IsoScene> {
    // Start a coroutine
    return (async () => {
      // Wait until the game starts running
      while (!this.gameInstance.isRunning) {
        await new Promise(resolve => {
          setTimeout(resolve, 0);
        });
      }

      return new Promise((resolve: (value: IsoScene) => void) => {
        // Subscribe to the loadcomplete event on the Loading Scene
        // Once the game loaded successfully, emit an event to the server
        this.gameInstance.scene.keys[CST.SCENES.LOAD].events.once(
          CST.EVENTS.LOAD_SCENE.LOAD_COMPLETE,
          (gameScene: IsoScene) => {
            this.socketManager.emit(GameLoaded.EVENT);

            resolve(gameScene);
          }
        );
      });
    })();
  }

  public static getInstance(): GameManager {
    return super.getInstance() as GameManager;
  }
}
